% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Bfimpute.R
\name{Bfimpute}
\alias{Bfimpute}
\title{Run Bfimpute}
\usage{
Bfimpute(
  counts,
  ccluster = c(7, "Spectrum"),
  label = NULL,
  normalized = FALSE,
  S_G = NULL,
  S_C = NULL,
  D = 32,
  totalepoch = 300,
  burnin = 200,
  sn_max = 10,
  sn_init = 1,
  threshold = 0.5,
  ncores = 5,
  out_dir = "./Bfimpute/",
  out_name = "Bfimpute",
  out_type = "all",
  returnUV = F
)
}
\arguments{
\item{counts}{Expression count matrix with rows corresponding to genes and
columns corresponding to cells.}

\item{ccluster}{The cluster approach: give \code{labeled} and corporate with
param \code{label} (see details in \code{label}) if the cells are labeled;
give a specific number and a spectral clustering approach chosen from
\code{Spectrum, specc} otherwise; and of cause you can use your own cluster
method and give us a function with a matrix as input and a vector as output
Default is \code{c(7,"Spectrum")}.}

\item{label}{Cell cluster labels which can be a vector, data.frame, matrix
with one row or one column, and etc (will only be used when \code{ccluster}
is set to \code{labeled}). Default is \code{NULL}.}

\item{normalized}{Whether the \code{counts} is raw or not. \code{FALSE} for
raw and \code{TRUE} for not. Default is \code{FALSE}.}

\item{S_G}{Gene latent matrix with \code{D} rows and the columns
corresponding to genes. Default is \code{NULL} which means no Gene latent
matrix.}

\item{S_C}{Cell latent matrix with \code{D} rows and the columns
corresponding to cells. Default is \code{NULL} which means no cell latent
matrix.}

\item{D}{Dimension of the latent factor. Default is \code{32}.}

\item{totalepoch}{Total number of epochs. Default is \code{300}.}

\item{burnin}{Number of burn-in epochs which are only be used as running
Markov chain. Default is \code{200}.}

\item{sn_max}{Maximum adaptive precision. Default is \code{10}.}

\item{sn_init}{Initial adaptive precision. Default is \code{1}.}

\item{threshold}{The threshold on dropout probabilities. Default is \code{0.5}.}

\item{ncores}{Number of cores used in parallel computation. Default is \code{5}.}

\item{out_dir}{The path and folder to store the results. Default is
\code{"./Bfimpute/"}.}

\item{out_name}{The file name which Bfimpute will save as. Default is
\code{"Bfimpute"}.}

\item{out_type}{The file type which Bfimpute will save as: "csv", "txt",
"rds", and "all" for all the three types, or "none" for just returning
without saving. Default is \code{"all"}.}

\item{returnUV}{Whether return the U and V matrices of the final epoch. If
\code{TRUE}, \code{Bfimpute} will return a list which consists of the imputed
matrix \code{R_calculate}, \code{U}, and \code{V}. If \code{FALSE},
\code{Bfimpute} will return the imputed matrix only. Default is \code{FALSE}.}
}
\value{
Bfimpute returns the imputed matrix with the same dimension as
\code{counts}. And it also saves the imputed count matrix to the specific
direction with specific name and types (depending on \code{out_dir},
\code{out_name}, and \code{out_type}).
}
\description{
Uses Bfimpute to recover drop-out events
}
\details{
Bfimpute is a powerful imputation tool for scRNA-seq data that
recovers the dropout event by factorizing the count matrix into the product
of gene-specific and cell-specific feature matrices. Bfimpute uses full
Bayesian inference to describe the latent information for genes and cells
and carries out a Markov chain Monte Carlo scheme which is able to easily
incorporates side information to train the model and perform the imputation.
}
\examples{
\donttest{
library(Bfimpute)
# use the following commands to generate simulated data
if(!requireNamespace("splatter", quietly = TRUE)) stop('The package splatter was not installed')
if(!requireNamespace("scater", quietly = TRUE)) stop('The package scater was not installed')
sce <- scater::mockSCE()
params <- splatter::splatEstimate(sce)
params <- splatter::setParams(params, update = list(nGenes = 20000,
                                          group.prob = rep(0.2,5),
                                          de.prob = 0.08,
                                          de.facLoc = 0.3,
                                          de.facScale = 0.5,
                                          batchCells = 500,
                                          dropout.type = "experiment"))
sim <- splatter::splatSimulate(params, method = "groups")
counts <- sim@assays@data@listData[["counts"]]
# impute via Bfimpute
counts_imputed <- Bfimpute(counts, ccluster = c(5,"specc"), label = NULL,
                           normalized = FALSE, S_G = NULL, S_C = NULL,
                           ncores = 5)
}

}
\references{
Wen et al.
Bfimpute: A Bayesian factorization method to recover single-cell RNA
sequencing data. \emph{bioRxiv}, 2021. doi:
\url{https://doi.org/10.1101/2021.02.10.430649}.

See more usage in \url{https://github.com/maiziezhoulab/Bfimpute}
}
\author{
Zi-Hang Wen, \email{wenzihang0506@gmail.com}

Xin (Maizie) Zhou, \email{maizie.zhou@vanderbilt.edu}
}
